//document.go
/*
一：多个进程并发的价值：
1.我们需要灵敏响应的用户图形界面，一方面程序还需要执行大量的运算或者IO密集操作，我们需要让界面响应与运算同时运行。
2.当我们的web服务器面对大量用户请求时，需要有更多的“web服务器工作单元”来分别响应用户。
3.我们的事务处于分布式环境上，相同的工作单元在不同的计算机上处理着被分片的数据。
4.计算机的cpu从单内核向着多内河发展，而我们的程序都是串行的，计算机硬件的能力没有得到发挥。
5.程序因为IO操作被阻塞，整个程序处于停滞状态，其他IO无关的任务无法执行。
*/
/*
二：并发的主流实现模型
1.多进程。多进程是在操作系统层面进行并发的基本模式，同时也是开销最大的模式。在Linux平台上，很多工具链接正是采用这种模式在工作
比如某个web服务器，它会有专门的进程负责网络端口的监听和连接管理，还会有专门的进程负责事务和运算。这种方法的好处在于简单、进程间
相互不影响，坏处在于系统开销大，因为所有的进程都是由内核管理的。
2.多线程。多线程在大部分操作系统上都属于系统层面的并发模式，也是我们使用最多的最有效的一种模式。目前，我们所见的几乎所有工具链都
会使用这种模式。它比进程的开销小很多，但是其开销依旧比较大，且在高并发模式下，效率会有影响。
3.基于回调的非阻塞/异步IO。这种架构的诞生实际上来源于多线程模式的危机。在很多高并发服务器开发实践中，使用多线程模式会很快耗尽服
务器的内存和cpu资源。而这种通过事件驱动的方式使用异步IO，使服务器持续运转，且尽可能的少用线程，降低开销，它目前在Node.js中得到
了很好的实践。但是使用这种模式，编程比多线程要复杂，因为它把流程做了分割，对于问题本身的反应不够自然。
4.协程。协程本质上是一种用户态线程，不需要操作系统来进行抢占式调度，且在真正的实现中寄存于线程中，因此，系统开销极小，可以有效提
高线程的任务并发性，而避免多线程的缺点。使用协程的优点是编程简单，结构清晰；缺点是需要语言的支持，如果不支持，则需要用户在程序中
自行实现调度器。目前，原生支持协程的语言还很少。
*/

/*
三：传统并发模型的缺陷及解决方法
1.共享内存系统：人的思维模式可以认为是串行的，而且串行的事物具有确定性。线程类并发模式在原先的确定性中引入了不确定性，这种不确定性给程序的行为带
来了意外和危害，让程序变得不可控。线程之间通信只能采用共享内存的方式。为了保证共享内存的有效性，我们采取了很多措施，比如加锁等，来
避免死锁或者资源竞争。实践证明，我们很难面面俱到，往往会在工程中遇到各种奇怪的故障和问题。
2.消息传递系统：对线程间共享状态的各种操作都被封装在线程之间传递的消息中，这通常要求：发送消息时对状态进行复制，并且在消息传递的边界上交出这个状态
的所有权限，从逻辑上来看，这个操作与共享内存系统中执行的原子更新操作相同，但从物理上来看则非常不同。由于需要执行复制操作，所以大多数消息传递的实现
在性能上并不优越，但线程中的状态管理工作通常会变得更为简单。
3.协程（执行体）：执行他是个抽象概念，在操作系统层面有多个概念与之对应，比如操作系统自己掌管的进程（process），进程内的线程（Thread），以及进程内的
协程（coroutine，也叫轻量级线程）。与传统的系统级线程和进程相比，协程的最大优势在于其“轻量级”，可以轻松创建上百万个而不会导致系统资源衰竭，而线程和进程
通常最多也不能超过1万个。这也是协程也叫轻量级线程的原因。
多数语言在语法层面并不支持协程，而是通过库的方式支持，但是库的方式支持的功能也并不完整，比如仅仅提供轻量级线程的创建、销毁与切换等功能，如果在这样的轻量级
线程中调用一个同步IO操作，比如网络通信，本地文件读写，都会阻塞其他的并发执行轻量级线程，从而无法真正达到轻量级线程本身期望达到的目标。
GO语言在语言级别支持轻量级线程，叫goroutine。GO语言标准库提供的所有系统调用操作（当然也包括所有同步IO操作），都会出让cpu给其他goroutine。这让事情变得非常简单
让轻量级线程的切换管理不依赖于系统的线程和进程，也不依赖于cpu的核心数量。
*/
/*
四：goroutine

*/
package goroutinesimple
